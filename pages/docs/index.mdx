# Risor Documentation

## Use Cases

### Configuration

A common use case for embedded scripting languages is to make an application
dynamically configurable, without the need for a recompile. In this case, an
embedded scripting language can provide a way to load and run configuration
scripts at runtime.

### Hot-reloading and Modularity

In large applications, being able to dynamically load, execute, and unload
scripts while the application is still running can lead to more modular code and
a faster development cycle. Risor can offer a flexible way to achieve this.

### End-User Scripting

If you want to provide a way for users to customize your application's behavior
or extend its functionality, Risor can be a good choice. Setups like this are
seen in many video games and software tools that provide APIs for modders and
plugin creators.

### Prototyping

Risor can be used for quick prototyping within your Go application. Thanks to
streamlined syntax and faster development cycles, this can be a great way to
implement a first version of new features. Later, if the feature is
well-received, the Risor code can be easily transformed into raw Go as needed.

### Interacting with Different Environments

Risor is convenient for working with different environments like OS commands,
web APIs, and databases. Because Risor has excellent libraries built-in, you
can jump right to the interesting work without spending time researching third
party libraries.

### Glue Code

Scripting languages are often used as "glue code". Risor is handy for
stitching together different systems due to its lightweight nature. Running a
Risor script (instead of compiling a Go binary) is great for small integration
tasks to support a larger application written in Go.
